(window["webpackJsonpdash_bio"] = window["webpackJsonpdash_bio"] || []).push([["async~needle"],{

/***/ "./src/lib/fragments/NeedlePlot.react.js":
/*!***********************************************!*\
  !*** ./src/lib/fragments/NeedlePlot.react.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return NeedlePlot; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_plotly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-plotly.js */ \"./node_modules/react-plotly.js/react-plotly.js\");\n/* harmony import */ var react_plotly_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_plotly_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ramda__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ramda */ \"./node_modules/ramda/es/index.js\");\n/* harmony import */ var _components_NeedlePlot_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/NeedlePlot.react */ \"./src/lib/components/NeedlePlot.react.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n/**\n * Checks if a variable is representation of a number or not\n * https://stackoverflow.com/questions/9716468/pure-javascript-a-function-like-jquerys-isnumeric\n * @param  {String/FLoat} n  A variable to test.\n * @return {Bool}            True if n is a number, false otherwise.\n */\n\nfunction isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * Converts an array elements to numbers and ignore the elements which are not\n * a representation of  numbers\n * @param  {Array} test_array An array\n * @return {Array}       An array with only numbers.\n */\n\n\nfunction filterNanArray(test_array) {\n  return test_array.filter(function (el) {\n    return Number(isNumeric(el));\n  });\n}\n/**\n * Search the protein position array for small protein domains (typically 1->5 sites)\n * and bogus entries (i.e. \"?-123\" or \"320-?\"), the protein domains are indicated\n * by the presence of a '-' character in the element of the array.\n * @param  {Array} protein_pos_array        An array containing protein domains\n * @return {Array} positions_array          An array with only single site\n\t\t\t\t\t    protein mutations.\n * @return {Array} domains_array            An array with only small domains\n\t\t\t\t\t    protein mutations.\n * @return {Array} idx_old_positions_array  An array with the indexes of the\n\t\t\t\t\t    single site protein mutations\n\t\t\t\t\t    relative to protein_pos_array\n * @return {Array} idx_bogus_entry          An array with the indexes of the\n\t\t\t\t\t    bogus entries (containing '?')\n\t\t\t\t\t    relative to protein_pos_array\n*/\n\n\nfunction extractSmallDomains(protein_pos_array) {\n  var positions_array = [];\n  var domains_array = [];\n  var idx_old_positions_array = [];\n  var idx_bogus_entry = [];\n  protein_pos_array.forEach(function (dx, i) {\n    if (dx.indexOf('-') > -1) {\n      var domains_limits = dx.split('-');\n\n      if (isNumeric(domains_limits[0]) || isNumeric(domains_limits[1])) {\n        idx_bogus_entry.push(i);\n      } else {\n        domains_array.push(dx);\n      }\n    } else {\n      idx_old_positions_array.push(i);\n      positions_array.push(dx);\n    }\n  });\n  return [positions_array, domains_array, idx_old_positions_array, idx_bogus_entry];\n}\n/**\n * Creates two arrays to plot horizontal lines with many markers\n *\n * @param  {number} xi  start x coordinate of the line\n * @param  {number} xf  stop x coordinate of the line\n * @param  {number} y   y coordinate of the line\n * @param  {int} n      number of markers\n * @return {array} x    x coordinates of the horizontal ine\n * @return {array} y    y coordinates of the horizontal ine\n */\n\n\nfunction createHorizontalLine(xi, xf, y, n) {\n  var dx = (xf - xi) / n;\n  var N = Math.max(2, n);\n  var x = Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"range\"])(0, N).map(function (i) {\n    return xi + i * dx;\n  });\n  return [x, Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"repeat\"])(y, N)];\n}\n/**\n * Finds the max of an array while ignoring the NaN values\n *\n * @param  {array} test_array  an array with numbers as entries\n * @return {number}            max value of the array\n */\n\n\nfunction nanMax(test_array) {\n  return Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"reduce\"])(ramda__WEBPACK_IMPORTED_MODULE_2__[\"max\"], -Infinity, filterNanArray(test_array));\n}\n/**\n * The Needle Plot component is used to visualize large datasets\n * containing categorical or numerical data. The lines and markers in\n * the plot correspond to bars in a histogram.\n **/\n\n\nvar NeedlePlot =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(NeedlePlot, _Component);\n\n  function NeedlePlot() {\n    var _this;\n\n    _classCallCheck(this, NeedlePlot);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NeedlePlot).call(this));\n    _this.state = {\n      xStart: null,\n      xEnd: null\n    };\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(NeedlePlot, [{\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      // For default argument of taken from defaultProps deeply nested\n      this.props = Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"mergeDeepRight\"])(NeedlePlot.defaultProps, this.props);\n    } // Handle plot events\n\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(event) {\n      // Zoom\n      if (event['xaxis.range[0]'] || event['xaxis.range']) {\n        this.setState({\n          xStart: event['xaxis.range[0]'] || event['xaxis.range'][0],\n          xEnd: event['xaxis.range[1]'] || event['xaxis.range'][1]\n        });\n      } // Autozoom\n      else if (event['xaxis.autorange'] === true) {\n          this.setState({\n            xStart: null,\n            xEnd: null\n          });\n        }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var id = this.props.id;\n\n      var _this$prepareTraces = this.prepareTraces(),\n          data = _this$prepareTraces.data,\n          globalAnnotation = _this$prepareTraces.globalAnnotation,\n          domainAnnotations = _this$prepareTraces.domainAnnotations;\n\n      var layout = this.prepareLayout({\n        data: data,\n        globalAnnotation: globalAnnotation,\n        domainAnnotations: domainAnnotations\n      });\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n        id: id\n      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_plotly_js__WEBPACK_IMPORTED_MODULE_1___default.a, _extends({\n        data: data,\n        layout: layout,\n        onRelayout: this.handleChange\n      }, Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"omit\"])(['setProps'], this.props))));\n    } // Fetch data\n\n  }, {\n    key: \"prepareTraces\",\n    value: function prepareTraces() {\n      var _mergeDeepRight = Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"mergeDeepRight\"])(NeedlePlot.defaultProps, this.props),\n          _mergeDeepRight$mutat = _mergeDeepRight.mutationData,\n          x = _mergeDeepRight$mutat.x,\n          y = _mergeDeepRight$mutat.y,\n          mutationGroups = _mergeDeepRight$mutat.mutationGroups,\n          domains = _mergeDeepRight$mutat.domains,\n          _mergeDeepRight$domai = _mergeDeepRight.domainStyle,\n          domainColor = _mergeDeepRight$domai.domainColor,\n          displayMinorDomains = _mergeDeepRight$domai.displayMinorDomains,\n          _mergeDeepRight$needl = _mergeDeepRight.needleStyle,\n          stemColor = _mergeDeepRight$needl.stemColor,\n          stemThickness = _mergeDeepRight$needl.stemThickness,\n          stemConstHeight = _mergeDeepRight$needl.stemConstHeight,\n          headSize = _mergeDeepRight$needl.headSize,\n          headColor = _mergeDeepRight$needl.headColor,\n          headSymbol = _mergeDeepRight$needl.headSymbol; // Apply filtering on protein positions\n\n\n      var _extractSmallDomains = extractSmallDomains(x),\n          _extractSmallDomains2 = _slicedToArray(_extractSmallDomains, 3),\n          x_single_site = _extractSmallDomains2[0],\n          small_domains = _extractSmallDomains2[1],\n          idx_old_positions_array = _extractSmallDomains2[2]; // manage whether headColor is an array or a string\n\n\n      var fixed_mutation_colors = Array.isArray(headColor) ? headColor : mutationGroups.map(function () {\n        return headColor;\n      });\n      var fixed_mutation_symbols = Array.isArray(headSymbol) ? headSymbol : mutationGroups.map(function () {\n        return headSymbol;\n      });\n      var fixed_domain_colors = domainColor;\n      var X_DATA_MIN = Math.min.apply(null, x_single_site);\n      var X_DATA_MAX = Math.max.apply(null, x_single_site);\n      var Y_DATA_MAX = stemConstHeight === true ? 1 : nanMax(y);\n      var X_RANGE_MIN = this.state.xStart || X_DATA_MIN;\n      var X_RANGE_MAX = this.state.xEnd || X_DATA_MAX;\n      var XSPAN = X_RANGE_MAX - X_RANGE_MIN; // this is used to trigger a change of display inside annotations\n\n      var XSPAN_RATIO = 0.2;\n      var Y_BUFFER = stemConstHeight === true ? 0.5 : Y_DATA_MAX / 10; // this is used to scale the position for the annotations\n\n      var Y_BUFFER_DIVIDER = 2;\n      var Y_TOP = stemConstHeight === true ? 2 : Y_DATA_MAX + Y_BUFFER;\n      var DOMAIN_WIDTH = 33;\n      var sequenceDomains = [];\n      var domainAnnotations = [];\n      var hoverlabels = []; // contains the height of each stem\n\n      var stemsY = [];\n      idx_old_positions_array.forEach(function (idx) {\n        if (stemConstHeight) {\n          stemsY = stemsY.concat([1]);\n        } else {\n          hoverlabels = hoverlabels.concat(['(' + x[idx] + ',' + y[idx] + ')']);\n          stemsY = stemsY.concat([y[idx]]);\n        }\n      });\n      var hoverinfo = stemConstHeight === true ? 'x+name+text' : 'name+text'; // build the different protein large domains\n\n      domains.forEach(function (dom, i) {\n        var domainLimits = dom.coord.split('-');\n        var x0 = Number(domainLimits[0]);\n        var x1 = Number(domainLimits[1]);\n        var domainLength = x1 - x0; // Highlight of the protein domain\n\n        sequenceDomains.push({\n          x: [x1, x0],\n          y: [Y_TOP, Y_TOP],\n          xaxis: 'x1',\n          name: dom.name,\n          fill: 'tozeroy',\n          mode: 'lines',\n          opacity: 0.5,\n          visible: 'legendonly',\n          legendgroup: dom.name,\n          marker: {\n            color: fixed_domain_colors[i]\n          }\n        });\n\n        var _createHorizontalLine = createHorizontalLine(x0, x1, -Y_BUFFER, x1 - x0),\n            _createHorizontalLine2 = _slicedToArray(_createHorizontalLine, 2),\n            line_x = _createHorizontalLine2[0],\n            line_y = _createHorizontalLine2[1];\n\n        sequenceDomains.push({\n          type: 'scatter',\n          mode: 'lines',\n          fill: 'tozeroy',\n          fillcolor: fixed_domain_colors[i],\n          hoveron: 'points+fills',\n          x: line_x,\n          y: line_y,\n          xaxis: 'x2',\n          showlegend: false,\n          hoverinfo: 'name',\n          name: \"[\".concat(x0, \"->\").concat(x1, \"] \").concat(dom.name),\n          marker: {\n            color: fixed_domain_colors[i]\n          },\n          line: {\n            width: 2\n          }\n        }); // Name of the protein domain\n\n        domainAnnotations.push({\n          x: (x0 + x1) / Y_BUFFER_DIVIDER,\n          y: -Y_BUFFER / Y_BUFFER_DIVIDER,\n          showarrow: false,\n          text: dom.name,\n          width: domainLength,\n          align: domainLength < XSPAN_RATIO * XSPAN ? 'right' : 'center'\n        });\n      });\n\n      if (displayMinorDomains === true) {\n        // build the different protein small domains\n        small_domains.forEach(function (dom) {\n          var x0 = Number(dom.split('-')[0]);\n          var x1 = Number(dom.split('-')[1]);\n          var gname = mutationGroups[x.indexOf(dom)];\n\n          var _createHorizontalLine3 = createHorizontalLine(x0, x1, -Y_BUFFER / Y_BUFFER_DIVIDER, x1 - x0),\n              _createHorizontalLine4 = _slicedToArray(_createHorizontalLine3, 2),\n              line_x = _createHorizontalLine4[0],\n              line_y = _createHorizontalLine4[1]; // Range of the protein domain on the xaxis\n\n\n          sequenceDomains.push({\n            type: 'scatter',\n            mode: 'lines',\n            x: line_x,\n            y: line_y,\n            fill: 'tozeroy',\n            fillcolor: fixed_mutation_colors[_toConsumableArray(new Set(mutationGroups)).indexOf(gname)],\n            hoveron: 'points+fills',\n            xaxis: 'x2',\n            hoverinfo: 'name+text',\n            name: gname,\n            text: \"[\".concat(x0, \"->\").concat(x1, \"] \"),\n            showlegend: false,\n            marker: {\n              color: fixed_mutation_colors[_toConsumableArray(new Set(mutationGroups)).indexOf(gname)]\n            },\n            line: {\n              width: DOMAIN_WIDTH\n            }\n          });\n        });\n      }\n\n      var globalAnnotation = [{\n        text: \"<b>\".concat(x_single_site.length + small_domains.length, \" Mutations</b>\"),\n        x: 0.01,\n        xref: 'paper',\n        y: 1.1,\n        yref: 'paper',\n        showarrow: false,\n        align: 'left'\n      }];\n      var data = [{\n        type: 'scatter',\n        mode: 'markers',\n        x: x_single_site,\n        y: stemsY,\n        xaxis: 'x1',\n        hoverinfo: hoverinfo,\n        text: hoverlabels,\n        error_y: {\n          type: 'data',\n          symmetric: false,\n          array: 0,\n          arrayminus: stemsY,\n          thickness: stemThickness,\n          width: 0,\n          color: stemColor\n        },\n        transforms: [{\n          type: 'groupby',\n          groups: mutationGroups,\n          nameformat: \"%{group}\",\n          styles: _toConsumableArray(new Set(mutationGroups)).map(function (target, i) {\n            return {\n              target: target,\n              value: {\n                marker: {\n                  size: headSize,\n                  symbol: fixed_mutation_symbols[i],\n                  color: fixed_mutation_colors[i]\n                }\n              }\n            };\n          })\n        }]\n      }].concat(sequenceDomains);\n      return {\n        data: data,\n        globalAnnotation: globalAnnotation,\n        domainAnnotations: domainAnnotations\n      };\n    } // Fetch layout\n\n  }, {\n    key: \"prepareLayout\",\n    value: function prepareLayout(vars) {\n      var data = vars.data,\n          globalAnnotation = vars.globalAnnotation,\n          domainAnnotations = vars.domainAnnotations;\n\n      var _mergeDeepRight2 = Object(ramda__WEBPACK_IMPORTED_MODULE_2__[\"mergeDeepRight\"])(NeedlePlot.defaultProps, this.props),\n          xlabel = _mergeDeepRight2.xlabel,\n          ylabel = _mergeDeepRight2.ylabel,\n          rangeSlider = _mergeDeepRight2.rangeSlider;\n\n      var _this$state = this.state,\n          xStart = _this$state.xStart,\n          xEnd = _this$state.xEnd;\n      var first_init = false; // initialize the range based on input data\n\n      if (Boolean(!xStart) || Boolean(!xEnd)) {\n        first_init = true;\n        data.forEach(function (trace) {\n          var X_DATA_MIN = Math.min.apply(null, trace.x);\n          var X_DATA_MAX = Math.max.apply(null, trace.x);\n\n          if (xStart > X_DATA_MIN || Boolean(!xStart)) {\n            xStart = X_DATA_MIN;\n          }\n\n          if (xEnd < X_DATA_MAX || Boolean(!xEnd)) {\n            xEnd = X_DATA_MAX;\n          }\n        });\n      } // this is used to zoom in the axis range initially\n\n\n      var XSTART_RATIO = 0.98;\n      var XEND_RATIO = 1.02;\n      var layout = {\n        legend: {\n          orientation: 'v',\n          x: 1,\n          y: 1.05,\n          bgcolor: 'rgba(255, 255, 255, 0)'\n        },\n        hovermode: 'closest',\n        xaxis: {\n          title: xlabel,\n          showgrid: false,\n          zeroline: false,\n          autorange: Boolean(!xStart),\n          range: [xStart, xEnd],\n          anchor: 'y'\n        },\n        xaxis2: {\n          scaleanchor: 'x',\n          autorange: Boolean(!xStart),\n          range: [xStart, xEnd],\n          anchor: 'y',\n          overlaying: 'x'\n        },\n        yaxis: {\n          title: ylabel,\n          showgrid: false,\n          ticks: 'inside'\n        },\n        margin: {\n          t: 100,\n          l: 40,\n          r: 0,\n          b: 40\n        },\n        annotations: domainAnnotations.concat(globalAnnotation)\n      };\n\n      if (rangeSlider === true) {\n        layout.xaxis.rangeslider = first_init === true ? {\n          range: [xStart * XSTART_RATIO, xEnd * XEND_RATIO]\n        } : {};\n      }\n\n      return layout;\n    }\n  }]);\n\n  return NeedlePlot;\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\n\n\nNeedlePlot.propTypes = _components_NeedlePlot_react__WEBPACK_IMPORTED_MODULE_3__[\"propTypes\"];\nNeedlePlot.defaultProps = _components_NeedlePlot_react__WEBPACK_IMPORTED_MODULE_3__[\"defaultProps\"];\n\n//# sourceURL=webpack://dash_bio/./src/lib/fragments/NeedlePlot.react.js?");

/***/ })

}]);