(window["webpackJsonpdash_bio"] = window["webpackJsonpdash_bio"] || []).push([["async~onco"],{

/***/ "./node_modules/react-oncoprint/lib/components/OncoPrint.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-oncoprint/lib/components/OncoPrint.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\n\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\"));\n\nvar _reactPlotly = _interopRequireDefault(__webpack_require__(/*! react-plotly.js */ \"./node_modules/react-plotly.js/react-plotly.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/react-oncoprint/lib/components/utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * The OncoPrint component is used to view multiple genetic alteration events\n * through an interactive and zoomable heatmap. It is a React/Dash port of the\n * popular oncoPrint() function from the BioConductor R package.\n * Under the hood, the rendering is done using Plotly.js built upon D3.\n * Plotly's interactivity allows the user to bind clicks and hovers to genetic\n * events, allowing the user to create complex bioinformatic apps or workflows\n * that rely on crossfiltering.\n * Read more about the component here:\n * https://github.com/plotly/react-oncoprint\n */\nvar OncoPrint =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(OncoPrint, _PureComponent);\n\n  // Constructor\n  function OncoPrint(props) {\n    var _this;\n\n    _classCallCheck(this, OncoPrint);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OncoPrint).call(this, props));\n    _this.state = {\n      xStart: null,\n      xEnd: null\n    };\n    _this.resetWindowing = _this.resetWindowing.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleChange = _lodash.default.debounce(_this.handleChange.bind(_assertThisInitialized(_assertThisInitialized(_this))), 250);\n    return _this;\n  } // Reset windowing to user preset on init or data change\n\n\n  _createClass(OncoPrint, [{\n    key: \"resetWindowing\",\n    value: function resetWindowing(props) {\n      var range = props.range;\n      var xStart, xEnd;\n\n      if (range.length === 2) {\n        xStart = range[0];\n        xEnd = range[1];\n      } else {\n        xStart = null;\n        xEnd = null;\n      }\n\n      return {\n        xStart: xStart,\n        xEnd: xEnd\n      };\n    } // Handle plot events\n\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(event) {\n      if (!this.props.onChange) {\n        return;\n      } // CLick (mousedown) or hover (mousemove)\n\n\n      if (event.points) {\n        var eventType;\n\n        if (event.event.type === \"mousedown\") {\n          eventType = 'Click';\n        } else if (event.event.type === \"mousemove\") {\n          eventType = 'Hover';\n        } else {\n          eventType = 'Other';\n        }\n\n        this.props.onChange({\n          eventType: eventType,\n          name: event.points[0].data.name,\n          text: event.points[0].text,\n          curveNumber: event.points[0].curveNumber,\n          x: event.points[0].x,\n          y: event.points[0].y\n        });\n      } // Zoom\n      else if (event['xaxis.range[0]'] || event['xaxis.range']) {\n          this.setState({\n            xStart: event['xaxis.range[0]'] || event['xaxis.range'][0],\n            xEnd: event['xaxis.range[1]'] || event['xaxis.range'][1]\n          });\n          this.props.onChange({\n            eventType: 'Zoom',\n            xStart: event['xaxis.range[0]'] || event['xaxis.range'][0],\n            xEnd: event['xaxis.range[1]'] || event['xaxis.range'][1]\n          });\n        } // Autozoom\n        else if (event['xaxis.autorange'] === true) {\n            this.setState({\n              xStart: null,\n              xEnd: null\n            });\n            this.props.onChange({\n              eventType: 'Autoscale'\n            });\n          } // Guard\n          else {\n              this.props.onChange(event);\n            }\n    }\n  }, {\n    key: \"getData\",\n    // Fetch data\n    value: function getData() {\n      var _this$props = this.props,\n          inputData = _this$props.data,\n          padding = _this$props.padding,\n          colorscale = _this$props.colorscale,\n          backgroundcolor = _this$props.backgroundcolor; // OncoPrint equivalent of x, y\n\n      var events = (0, _utils.aggregate)(inputData);\n      var genes = (0, _utils.getSortedGenes)(inputData);\n      var samples = (0, _utils.getSortedSamples)(inputData);\n      var ratios = (0, _utils.getEventRatiosPerGene)(inputData, samples.length);\n\n      var formatGenes = function formatGenes(list) {\n        return list.map(function (gene) {\n          return \"\".concat(gene, \" (\").concat(ratios[gene], \"%)\");\n        });\n      };\n\n      var base = 0;\n      var bBackground = [];\n      var tBackground = [];\n      var xBackground = [];\n      var yBackground = []; // Background is used to draw the matrix (genes * samples)\n\n      samples.forEach(function (s) {\n        bBackground.push.apply(bBackground, _toConsumableArray(Array(genes.length).fill(base)));\n        tBackground.push.apply(tBackground, _toConsumableArray(Array(genes.length).fill(s)));\n        xBackground.push.apply(xBackground, _toConsumableArray(Array(genes.length).fill(1)));\n        yBackground.push.apply(yBackground, _toConsumableArray(formatGenes(genes)));\n        base += 1;\n      });\n      var background = {\n        base: bBackground.map(function (i) {\n          return i + padding;\n        }),\n        hoverinfo: 'text',\n        marker: {\n          color: backgroundcolor\n        },\n        name: 'No alteration',\n        text: tBackground,\n        orientation: 'h',\n        type: 'bar',\n        x: xBackground.map(function (i) {\n          return i - padding * 2;\n        }),\n        y: yBackground\n      };\n      var data = [background];\n      Object.keys(events).forEach(function (key) {\n        var aggr = events[key]; // Resize width depending on the mutation type\n\n        var width = 0.4;\n\n        if (aggr.type === 'CNA') {\n          width = 0.8;\n        } else if (aggr.type === 'EXP') {\n          width = 0.6;\n        } // Mutations should have the original text on it, not the type of mutation\n\n\n        var text_arr = aggr.events.map(function (event) {\n          return \"\".concat(event.sample, \"<br>\").concat((0, _utils.getDisplayName)(event));\n        }); // where to draw a bar for this entry\n\n        var indexes = aggr.events.map(function (e) {\n          return e.sample;\n        }).map(function (s) {\n          return samples.findIndex(function (sample) {\n            return sample === s;\n          });\n        });\n        data.push({\n          base: indexes.map(function (i) {\n            return i + padding;\n          }),\n          hoverinfo: 'text',\n          marker: {\n            color: (0, _utils.getColor)(aggr.events[0], colorscale)\n          },\n          name: (0, _utils.getDisplayName)(aggr.events[0]),\n          text: text_arr,\n          orientation: 'h',\n          type: 'bar',\n          width: width,\n          x: Array(aggr.events.length).fill(1).map(function (i) {\n            return i - padding * 2;\n          }),\n          y: formatGenes((0, _utils.getGeneNames)(aggr.events))\n        });\n      });\n      return data;\n    } // Fetch layout\n\n  }, {\n    key: \"getLayout\",\n    value: function getLayout() {\n      var _this$props2 = this.props,\n          showlegend = _this$props2.showlegend,\n          showoverview = _this$props2.showoverview,\n          width = _this$props2.width,\n          height = _this$props2.height;\n      var _this$state = this.state,\n          xStart = _this$state.xStart,\n          xEnd = _this$state.xEnd; // Get initial range\n\n      var initialRange = [xStart, xEnd];\n      var layout = {\n        barmode: 'stack',\n        hovermode: 'closest',\n        showlegend: showlegend,\n        xaxis: {\n          showgrid: false,\n          showticklabels: false,\n          zeroline: false,\n          range: initialRange,\n          automargin: true\n        },\n        yaxis: {\n          showgrid: false,\n          zeroline: false,\n          fixedrange: true,\n          automargin: true\n        },\n        margin: {\n          t: 20,\n          r: 20,\n          b: 20\n        }\n      };\n\n      if (showoverview) {\n        layout.xaxis.rangeslider = {\n          autorange: true\n        };\n      }\n\n      return {\n        layout: layout,\n        width: width,\n        height: height\n      };\n    } // Set xStart and xEnd on load\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$resetWindowing = this.resetWindowing(this.props),\n          xStart = _this$resetWindowing.xStart,\n          xEnd = _this$resetWindowing.xEnd;\n\n      this.setState({\n        xStart: xStart,\n        xEnd: xEnd\n      });\n    } // Reset xStart and xEnd on data change\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (this.props.data !== prevProps.data) {\n        var _this$resetWindowing2 = this.resetWindowing(this.props),\n            xStart = _this$resetWindowing2.xStart,\n            xEnd = _this$resetWindowing2.xEnd;\n\n        this.setState({\n          xStart: xStart,\n          xEnd: xEnd\n        });\n      }\n    } // Main\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var data = this.getData();\n\n      var _this$getLayout = this.getLayout(),\n          layout = _this$getLayout.layout,\n          width = _this$getLayout.width,\n          height = _this$getLayout.height;\n\n      var other = {\n        style: {\n          width: width,\n          height: height\n        },\n        useResizeHandler: true\n      };\n      return _react.default.createElement(\"div\", null, _react.default.createElement(_reactPlotly.default, _extends({\n        data: data,\n        layout: layout,\n        onClick: this.handleChange,\n        onHover: this.handleChange,\n        onRelayout: this.handleChange\n      }, other)));\n    }\n  }]);\n\n  return OncoPrint;\n}(_react.PureComponent);\n\nexports.default = OncoPrint;\nOncoPrint.propTypes = {\n  /**\n   * Input data, in CBioPortal format where each list entry is a dict\n   * consisting of 'sample', 'gene', 'alteration', and 'type'\n   */\n  data: _propTypes.default.array,\n  // TODO: Add remove empty columns prop\n\n  /**\n   * Adjusts the padding (as a proportion of whitespace) between two tracks.\n   * Value is a ratio between 0 and 1.\n   * Defaults to 0.05 (e.g. 5%). If set to 0, plot will look like a heatmap.\n   */\n  padding: _propTypes.default.number,\n\n  /**\n   * If not null, will override the default OncoPrint colorscale.\n   * Default OncoPrint colorscale same as CBioPortal implementation.\n   * Make your own colrscale as a {'mutation': COLOR} dict.\n   * Supported mutation keys are ['MISSENSE, 'INFRAME', 'FUSION',\n   * 'AMP', 'GAIN', 'HETLOSS', 'HMODEL', 'UP', 'DOWN']\n   * Note that this is NOT a standard plotly colorscale.\n   */\n  colorscale: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.object]),\n\n  /**\n   * Default color for the tracks, in common name, hex, rgb or rgba format.\n   * If left blank, will default to a light grey rgb(190, 190, 190).\n   */\n  backgroundcolor: _propTypes.default.string,\n\n  /**\n   *.Toogles whether or not to show a legend on the right side of the plot,\n   * with mutation information.\n   */\n  range: _propTypes.default.array,\n\n  /**\n   *.Toogles whether or not to show a legend on the right side of the plot,\n   * with mutation information.\n   */\n  showlegend: _propTypes.default.bool,\n\n  /**\n   *.Toogles whether or not to show a heatmap overview of the tracks.\n   */\n  showoverview: _propTypes.default.bool,\n\n  /**\n   * Width of the OncoPrint.\n   * Will disable auto-resizing of plots if set.\n   */\n  width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n\n  /**\n   * Height of the OncoPrint.\n   * Will disable auto-resizing of plots if set.\n   */\n  height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])\n};\nOncoPrint.defaultProps = {\n  // Data\n  padding: 0.05,\n  colorscale: null,\n  backgroundcolor: 'rgb(190, 190, 190)',\n  // Layout\n  range: [null, null],\n  showlegend: true,\n  showoverview: true,\n  // Other\n  width: null,\n  height: 500\n};\n\n//# sourceURL=webpack://dash_bio/./node_modules/react-oncoprint/lib/components/OncoPrint.js?");

/***/ }),

/***/ "./node_modules/react-oncoprint/lib/components/PrecomputedComparator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-oncoprint/lib/components/PrecomputedComparator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.hasElementsInInterval = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar hasElementsInInterval = function hasElementsInInterval(arr, func, lowerBound, upperBound) {\n  // in: arr, an array sorted in increasing order of func\n  //     func, a function that takes an element of sorted_list and returns a number\n  //     lowerBound and upperBound: define a half-open interval [lowerBound, upperBound)\n  // out: boolean, true iff there are any elements whose image under func is in [lowerBound, upperBound)\n  var lowerCounter = 0;\n  var upperCounter = arr.length;\n  var middle, middle_val;\n\n  while (true) {\n    if (lowerCounter >= upperCounter) {\n      return false;\n    }\n\n    middle = Math.floor((lowerCounter + upperCounter) / 2);\n    middle_val = func(arr[middle]);\n\n    if (middle_val >= upperBound) {\n      upperCounter = middle;\n    } else if (middle_val < lowerBound) {\n      lowerCounter = middle + 1;\n    } else {\n      // otherwise, the middle value is inside the interval,\n      // so there's at least one value inside the interval\n      return true;\n    }\n  }\n}; // PrecomputedComparator is similar to the OncoPrintJs implementation with\n// three notable changes: rewritten with Flow/ES next and as a class, the input\n// data structure is different, and no direction.\n\n\nexports.hasElementsInInterval = hasElementsInInterval;\n\nvar PrecomputedComparator =\n/*#__PURE__*/\nfunction () {\n  function PrecomputedComparator(data, comparator) {\n    _classCallCheck(this, PrecomputedComparator);\n\n    this.comparator = comparator;\n    this.data = data;\n    this.sort();\n  }\n\n  _createClass(PrecomputedComparator, [{\n    key: \"sort\",\n    value: function sort() {\n      this.sortedData = this.data.sort(this.comparator);\n      this.changePoints = [];\n\n      for (var i = 0; i < this.sortedData.length; i += 1) {\n        if (i === this.sortedData.length - 1) {\n          break;\n        }\n\n        if (this.comparator(this.sortedData[i], this.sortedData[i + 1]) !== 0) {\n          this.changePoints.push(i);\n        }\n      }\n\n      this.samplesToIndex = {};\n\n      for (var _i = 0; _i < this.sortedData.length; _i += 1) {\n        this.samplesToIndex[this.sortedData[_i]] = _i;\n      }\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(s1, s2) {\n      var i1 = this.samplesToIndex[s1];\n      var i2 = this.samplesToIndex[s2];\n\n      if (typeof i1 === 'undefined' && typeof i2 === 'undefined') {\n        return 0;\n      } else if (typeof i1 === 'undefined') {\n        return 1;\n      } else if (typeof i2 === 'undefined') {\n        return -1;\n      }\n\n      var shouldNegateResult = false;\n\n      if (i1 === i2) {\n        return 0;\n      } else if (i1 > i2) {\n        var tmp = i1;\n        i1 = i2;\n        i2 = tmp;\n        shouldNegateResult = true;\n      }\n\n      var res = 0;\n\n      if (hasElementsInInterval(this.changePoints, function (x) {\n        return x;\n      }, i1, i2)) {\n        res = -1;\n      }\n\n      if (shouldNegateResult) {\n        res *= -1;\n      }\n\n      return res;\n    }\n  }]);\n\n  return PrecomputedComparator;\n}();\n\nexports.default = PrecomputedComparator;\n\n//# sourceURL=webpack://dash_bio/./node_modules/react-oncoprint/lib/components/PrecomputedComparator.js?");

/***/ }),

/***/ "./node_modules/react-oncoprint/lib/components/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-oncoprint/lib/components/utils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getColor = exports.getDisplayName = exports.aggregate = exports.getSortedSamples = exports.createSortEventsForGeneComparator = exports.createSamplesMap = exports.isMutation = exports.getEventRatiosPerGene = exports.getSortedGenes = exports.getGeneNames = exports.SupportedEvents = void 0;\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\"));\n\nvar _PrecomputedComparator = _interopRequireDefault(__webpack_require__(/*! ./PrecomputedComparator */ \"./node_modules/react-oncoprint/lib/components/PrecomputedComparator.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nvar MutationEventTypes = ['INFRAME', 'TRUNC', 'MISSENSE'];\nvar SupportedEvents = {\n  // Mutations\n  MISSENSE: {\n    colorHTML: '#008000',\n    displayName: 'Missense mutation'\n  },\n  INFRAME: {\n    colorHTML: '#993404',\n    displayName: 'Inframe mutation'\n  },\n  TRUNC: {\n    colorHTML: '#000000',\n    displayName: 'Truncation mutation'\n  },\n  // Fusion\n  FUSION: {\n    colorHTML: '#8b00c9',\n    displayName: 'Fusion'\n  },\n  // Copy number alterations\n  AMP: {\n    colorHTML: '#ff0000',\n    displayName: 'Amplification'\n  },\n  GAIN: {\n    colorHTML: '#ffb6c1',\n    displayName: 'Gain'\n  },\n  HETLOSS: {\n    colorHTML: '#8fd8d8',\n    displayName: 'Shallow deletion'\n  },\n  HOMDEL: {\n    colorHTML: '#0000ff',\n    displayName: 'Deep deletion'\n  },\n  // mRNA expressions\n  UP: {\n    colorHTML: '#ff9999',\n    displayName: 'mRNA Upregulation'\n  },\n  DOWN: {\n    colorHTML: '#6699cc',\n    displayName: 'mRNA Downregulation'\n  }\n}; // Describes the order of importance for CNA events.\n\nexports.SupportedEvents = SupportedEvents;\nvar AlterationsOrder = {\n  AMP: 0,\n  GAIN: 2,\n  HETLOSS: 3,\n  HOMDEL: 1,\n  undefined: 4\n}; // Describes the order of importance for mutation events.\n\nvar MutationsOrder = {\n  INFRAME: 1,\n  MISSENSE: 3,\n  TRUNC: 0,\n  undefined: 4\n}; // Describes the order of importance for mRNA expression events.\n\nvar ExpressionsOrder = {\n  UP: 0,\n  DOWN: 1,\n  undefined: 2\n}; // Retrieves the gene names in a set of events.\n\nvar getGeneNames = function getGeneNames(events) {\n  return events.map(function (e) {\n    return e.gene;\n  }).filter(function (gene) {\n    return gene !== null;\n  });\n}; // Returns the set of genes (unique) reversed to display on the Y axis.\n\n\nexports.getGeneNames = getGeneNames;\n\nvar getSortedGenes = function getSortedGenes(events) {\n  return _toConsumableArray(new Set(getGeneNames(events))).reverse();\n}; // Returns a hash map with the percentage of events (value) per gene (key).\n\n\nexports.getSortedGenes = getSortedGenes;\n\nvar getEventRatiosPerGene = function getEventRatiosPerGene(events, nbSamples) {\n  var map = events.reduce(function (acc, event) {\n    if (event.type) {\n      if (acc[event.gene]) {\n        acc[event.gene] += 1;\n      } else {\n        acc[event.gene] = 1;\n      }\n    }\n\n    return acc;\n  }, {});\n  Object.keys(map).forEach(function (gene) {\n    map[gene] = Math.floor(map[gene] / nbSamples * 100);\n  });\n  return map;\n}; // Returns true if an event is a mutation, false otherwise.\n\n\nexports.getEventRatiosPerGene = getEventRatiosPerGene;\n\nvar isMutation = function isMutation(event) {\n  return MutationEventTypes.includes(event.type);\n}; // Returns a comparator result value given an integer that may not be -1, 0 or\n// 1 (which are the only allowed sorting return values).\n\n\nexports.isMutation = isMutation;\n\nvar sign = function sign(x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  }\n\n  return 0;\n}; // Returns a comparator for the samples (matrix column), combining all the\n// precomputed comparators created for each gene (i.e. matrix row).\n\n\nvar samplesComparator = function samplesComparator(genes, samplesToIndex, perGeneComparators) {\n  return function (s1, s2) {\n    var result = 0;\n    var absoluteResult = 0;\n\n    for (var i = 0; i < genes.length; i += 1) {\n      var nextResult = perGeneComparators[i].compare(s1, s2);\n      var nextAbsoluteResult = Math.abs(nextResult);\n\n      if (nextAbsoluteResult > absoluteResult) {\n        result = nextResult;\n        absoluteResult = nextAbsoluteResult;\n      }\n\n      if (absoluteResult === 1) {\n        break;\n      }\n    }\n\n    if (result === 0) {\n      result = samplesToIndex[s1] < samplesToIndex[s2] ? -1 : 1;\n    }\n\n    return result > 0 ? 1 : -1;\n  };\n}; // Returns a comparator to sort the samples given a gene .\n\n\nvar sortEventsForGene = function sortEventsForGene(s1, s2, gene, samplesMap) {\n  var d1 = samplesMap[s1][gene] || {};\n  var d2 = samplesMap[s2][gene] || {};\n\n  if (d1.FUSION && !d2.FUSION) {\n    return -1;\n  } else if (!d1.FUSION && d2.FUSION) {\n    return 1;\n  }\n\n  var cna = sign(AlterationsOrder[d1.CNA] - AlterationsOrder[d2.CNA]);\n\n  if (cna !== 0) {\n    return cna;\n  }\n\n  var mut = sign(MutationsOrder[d1.MUT] - MutationsOrder[d2.MUT]);\n\n  if (mut !== 0) {\n    return mut;\n  }\n\n  var exp = sign(ExpressionsOrder[d1.EXP] - ExpressionsOrder[d2.EXP]);\n\n  if (exp !== 0) {\n    return exp;\n  }\n\n  return 0;\n}; // Returns a map to gather information on each sample, per gene, per event.\n\n\nvar createSamplesMap = function createSamplesMap(events) {\n  var samplesMap = {};\n  events.forEach(function (e) {\n    var s = samplesMap[e.sample] || {};\n    var v = s[e.gene] || {};\n\n    if (isMutation(e)) {\n      v.MUT = e.type;\n    } else {\n      v[e.type] = e.alteration;\n    }\n\n    samplesMap[e.sample] = Object.assign({}, samplesMap[e.sample], _defineProperty({}, e.gene, v));\n  });\n  return samplesMap;\n}; // Helper function to create a comparator for each gene.\n\n\nexports.createSamplesMap = createSamplesMap;\n\nvar createSortEventsForGeneComparator = function createSortEventsForGeneComparator(gene, map) {\n  return function (s1, s2) {\n    return sortEventsForGene(s1, s2, gene, map);\n  };\n}; // Returns the list of samples sorted with mutual exclusion. The sorting\n// algorithm is similar to the one used on cBioPortal and takes both the rows\n// (genes) and columns (samples) into account. We returns the sorted set of\n// samples to display on X axix.\n\n\nexports.createSortEventsForGeneComparator = createSortEventsForGeneComparator;\n\nvar getSortedSamples = function getSortedSamples(events) {\n  // Get a map with samples sorted by gene and events.\n  var samplesMap = createSamplesMap(events); // Get a unique list of genes, sorted by the natural order in the events.\n\n  var genes = _toConsumableArray(new Set(getGeneNames(events))); // Sort the samples alphabetically.\n\n\n  var samples = _toConsumableArray(new Set(events.map(function (e) {\n    return e.sample;\n  }))).sort(); // Build one comparator per gene.\n\n\n  var perGeneComparators = [];\n  genes.forEach(function (gene) {\n    perGeneComparators.push( // This actually sorts the samples, but for each gene only.\n    new _PrecomputedComparator.default(_toConsumableArray(samples), createSortEventsForGeneComparator(gene, samplesMap)));\n  }); // Create a map with the current order of the samples.\n\n  var samplesToIndex = {};\n  samples.forEach(function (s, i) {\n    samplesToIndex[s] = i;\n  }); // Finally, sort the samples taking into account both the columns and rows.\n\n  var sortedSamples = _toConsumableArray(samples);\n\n  sortedSamples.sort(samplesComparator(genes, samplesToIndex, perGeneComparators));\n  return sortedSamples;\n}; // Returns the events aggregated by type (if mutation) or alteration.\n\n\nexports.getSortedSamples = getSortedSamples;\n\nvar aggregate = function aggregate(events) {\n  var out = {};\n  events.forEach(function (e) {\n    if (!e.type || e.type === 'NONE') {\n      return;\n    }\n\n    var k = isMutation(e) ? e.type : e.alteration;\n    var v = out[k] || {\n      type: e.type,\n      alteration: e.alteration,\n      events: []\n    };\n    v.events.push(e);\n    out[k] = v;\n  });\n  return out;\n}; // Returns the display name of an event.\n\n\nexports.aggregate = aggregate;\n\nvar getDisplayName = function getDisplayName(event) {\n  var eventName = isMutation(event) ? event.type : event.alteration;\n  return SupportedEvents[eventName].displayName;\n}; // Returns the color of an event.\n\n\nexports.getDisplayName = getDisplayName;\n\nvar getColor = function getColor(event, colorscale) {\n  var eventName = isMutation(event) ? event.type : event.alteration;\n  var color;\n\n  if (colorscale && _lodash.default.isObject(colorscale)) {\n    color = colorscale[eventName]; // Revert back to default scale if not found\n\n    if (!color) {\n      color = SupportedEvents[eventName].colorHTML;\n    }\n  } else {\n    color = SupportedEvents[eventName].colorHTML;\n  }\n\n  return color;\n};\n\nexports.getColor = getColor;\n\n//# sourceURL=webpack://dash_bio/./node_modules/react-oncoprint/lib/components/utils.js?");

/***/ }),

/***/ "./node_modules/react-oncoprint/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-oncoprint/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"OncoPrint\", {\n  enumerable: true,\n  get: function get() {\n    return _OncoPrint.default;\n  }\n});\n\nvar _OncoPrint = _interopRequireDefault(__webpack_require__(/*! ./components/OncoPrint */ \"./node_modules/react-oncoprint/lib/components/OncoPrint.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://dash_bio/./node_modules/react-oncoprint/lib/index.js?");

/***/ }),

/***/ "./src/lib/fragments/OncoPrint.react.js":
/*!**********************************************!*\
  !*** ./src/lib/fragments/OncoPrint.react.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OncoPrint; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ramda__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ramda */ \"./node_modules/ramda/es/index.js\");\n/* harmony import */ var react_oncoprint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-oncoprint */ \"./node_modules/react-oncoprint/lib/index.js\");\n/* harmony import */ var react_oncoprint__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_oncoprint__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_OncoPrint_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/OncoPrint.react */ \"./src/lib/components/OncoPrint.react.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar OncoPrint =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(OncoPrint, _Component);\n\n  function OncoPrint(props) {\n    var _this;\n\n    _classCallCheck(this, OncoPrint);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OncoPrint).call(this, props));\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));\n    return _this;\n  } // Bind to Dash event handler that puts event back into props\n\n\n  _createClass(OncoPrint, [{\n    key: \"handleChange\",\n    value: function handleChange(event) {\n      var eventObj = JSON.stringify(event);\n      this.props.setProps({\n        eventDatum: eventObj\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          id = _this$props.id,\n          eventDatum = _this$props.eventDatum;\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n        id: id,\n        eventDatum: eventDatum\n      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_oncoprint__WEBPACK_IMPORTED_MODULE_2__[\"OncoPrint\"], _extends({\n        onChange: this.handleChange\n      }, Object(ramda__WEBPACK_IMPORTED_MODULE_1__[\"omit\"])(['setProps'], this.props))));\n    }\n  }]);\n\n  return OncoPrint;\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\n\n\nOncoPrint.defaultProps = _components_OncoPrint_react__WEBPACK_IMPORTED_MODULE_3__[\"defaultProps\"];\nOncoPrint.propTypes = _components_OncoPrint_react__WEBPACK_IMPORTED_MODULE_3__[\"propTypes\"];\n\n//# sourceURL=webpack://dash_bio/./src/lib/fragments/OncoPrint.react.js?");

/***/ })

}]);